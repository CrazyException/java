package DisruptorSample;import com.lmax.disruptor.BusySpinWaitStrategy;import com.lmax.disruptor.dsl.Disruptor;import com.lmax.disruptor.dsl.EventHandlerGroup;import com.lmax.disruptor.dsl.ProducerType;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * Created with IntelliJ IDEA. * Project: test-jar * Author: Kevin * Date: 16/5/24 * Time: 下午8:08 */public class ComplexDemo {	public static void main(String[] args) throws InterruptedException {		long beginTime=System.currentTimeMillis();		int bufferSize=2;		ExecutorService executor= Executors.newFixedThreadPool(4);				Disruptor<TestObject> disruptor = new Disruptor<TestObject>(new TestObjectFactory(), bufferSize, executor, ProducerType.SINGLE, new BusySpinWaitStrategy());		//使用disruptor创建消费者组C1,C2		EventHandlerGroup<TestObject> handlerGroup=disruptor.handleEventsWith(new TestObjectHandler(),new TestObjectDBHandler());		//声明在C1,C2完事之后执行JMS消息发送操作 也就是流程走到C3		handlerGroup.then(new TestObjectNotifyHandler());		disruptor.start();//启动		CountDownLatch latch=new CountDownLatch(1);		//生产者准备		executor.submit(new TestObjectPublisher(latch, disruptor));		latch.await();//等待生产者完事.		disruptor.shutdown();		executor.shutdown();		System.out.println("总耗时:"+(System.currentTimeMillis()-beginTime));	}}